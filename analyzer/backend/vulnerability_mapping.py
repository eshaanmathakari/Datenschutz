"""
Vulnerability mapping system for CWE/CVE classification and compliance standards.
Maps detected security issues to standard vulnerability classifications.
"""

from typing import Dict, List, Optional, Any
import json
import os

# CWE (Common Weakness Enumeration) mappings
CWE_MAPPINGS = {
    "sql_injection": {
        "cwe_id": "CWE-89",
        "title": "SQL Injection",
        "description": "Improper neutralization of special elements used in an SQL Command",
        "owasp_category": "A03:2021 - Injection",
        "severity_base": "high"
    },
    "xss": {
        "cwe_id": "CWE-79", 
        "title": "Cross-site Scripting",
        "description": "Improper neutralization of input during web page generation",
        "owasp_category": "A03:2021 - Injection",
        "severity_base": "medium"
    },
    "command_injection": {
        "cwe_id": "CWE-78",
        "title": "OS Command Injection", 
        "description": "Improper neutralization of special elements used in an OS Command",
        "owasp_category": "A03:2021 - Injection",
        "severity_base": "critical"
    },
    "path_traversal": {
        "cwe_id": "CWE-22",
        "title": "Path Traversal",
        "description": "Improper limitation of a pathname to a restricted directory",
        "owasp_category": "A01:2021 - Broken Access Control",
        "severity_base": "high"
    },
    "hardcoded_secrets": {
        "cwe_id": "CWE-798",
        "title": "Use of Hard-coded Credentials",
        "description": "Software contains hard-coded credentials",
        "owasp_category": "A07:2021 - Identification and Authentication Failures",
        "severity_base": "critical"
    },
    "weak_crypto": {
        "cwe_id": "CWE-327",
        "title": "Use of a Broken or Risky Cryptographic Algorithm",
        "description": "Use of a broken or risky cryptographic algorithm",
        "owasp_category": "A02:2021 - Cryptographic Failures",
        "severity_base": "high"
    },
    "insecure_random": {
        "cwe_id": "CWE-338",
        "title": "Use of Cryptographically Weak Pseudo-Random Number Generator",
        "description": "Use of cryptographically weak pseudo-random number generator",
        "owasp_category": "A02:2021 - Cryptographic Failures", 
        "severity_base": "medium"
    },
    "xml_external_entity": {
        "cwe_id": "CWE-611",
        "title": "XML External Entity Reference",
        "description": "Improper restriction of XML external entity reference",
        "owasp_category": "A05:2021 - Security Misconfiguration",
        "severity_base": "high"
    },
    "buffer_overflow": {
        "cwe_id": "CWE-120",
        "title": "Buffer Copy without Checking Size of Input",
        "description": "Classic buffer overflow", 
        "owasp_category": "A06:2021 - Vulnerable and Outdated Components",
        "severity_base": "critical"
    },
    "insecure_deserialization": {
        "cwe_id": "CWE-502",
        "title": "Deserialization of Untrusted Data",
        "description": "Deserialization of untrusted data",
        "owasp_category": "A08:2021 - Software and Data Integrity Failures",
        "severity_base": "critical"
    },
    "insufficient_logging": {
        "cwe_id": "CWE-778",
        "title": "Insufficient Logging",
        "description": "Insufficient logging of security-relevant events",
        "owasp_category": "A09:2021 - Security Logging and Monitoring Failures",
        "severity_base": "low"
    },
    "ssrf": {
        "cwe_id": "CWE-918",
        "title": "Server-Side Request Forgery",
        "description": "Server-side request forgery",
        "owasp_category": "A10:2021 - Server-Side Request Forgery",
        "severity_base": "high"
    }
}

# Compliance framework mappings
COMPLIANCE_MAPPINGS = {
    "pci_dss": {
        "name": "PCI DSS 4.0",
        "requirements": {
            "6.2.4": "Custom application security",
            "6.3.2": "Code review processes", 
            "11.3.1": "Application penetration testing",
            "11.3.2": "Network penetration testing"
        }
    },
    "iso_27001": {
        "name": "ISO 27001:2022",
        "controls": {
            "A.8.24": "Information systems security testing",
            "A.8.25": "Application security testing", 
            "A.8.29": "Information security testing in development"
        }
    },
    "nist_csf": {
        "name": "NIST Cybersecurity Framework 2.0",
        "functions": {
            "ID.RA": "Risk Assessment",
            "PR.DS": "Data Security",
            "DE.CM": "Continuous Monitoring",
            "RS.AN": "Analysis and Investigation"
        }
    },
    "hipaa": {
        "name": "HIPAA Security Rule",
        "safeguards": {
            "164.308": "Administrative Safeguards",
            "164.310": "Physical Safeguards",
            "164.312": "Technical Safeguards"
        }
    }
}

# Known CVE patterns for common vulnerabilities
CVE_PATTERNS = {
    "flask_debug": {
        "cves": ["CVE-2023-30861"],
        "description": "Flask debug mode exposure"
    },
    "django_secret": {
        "cves": ["CVE-2022-28346"],
        "description": "Django SECRET_KEY exposure"
    },
    "requests_verify": {
        "cves": ["CVE-2023-32681"],
        "description": "Requests library SSL verification bypass"
    }
}

class VulnerabilityMapper:
    """Maps detected vulnerabilities to security standards and classifications."""
    
    def __init__(self):
        self.cwe_db = CWE_MAPPINGS
        self.compliance_db = COMPLIANCE_MAPPINGS
        self.cve_db = CVE_PATTERNS
    
    def classify_vulnerability(self, vulnerability_type: str, details: Dict[str, Any]) -> Dict[str, Any]:
        """
        Classify a vulnerability with CWE, OWASP, and compliance mappings.
        
        Args:
            vulnerability_type: Type of vulnerability (e.g., 'sql_injection')
            details: Additional details about the specific vulnerability
            
        Returns:
            Dict containing classification information
        """
        classification = {
            "vulnerability_type": vulnerability_type,
            "cwe": None,
            "owasp_category": None,
            "cves": [],
            "compliance_impact": [],
            "severity": details.get("severity", "medium"),
            "risk_score": 0
        }
        
        # Map to CWE
        if vulnerability_type in self.cwe_db:
            cwe_info = self.cwe_db[vulnerability_type]
            classification["cwe"] = {
                "id": cwe_info["cwe_id"],
                "title": cwe_info["title"],
                "description": cwe_info["description"]
            }
            classification["owasp_category"] = cwe_info["owasp_category"]
            classification["severity"] = cwe_info["severity_base"]
        
        # Check for known CVEs
        classification["cves"] = self._find_relevant_cves(vulnerability_type, details)
        
        # Map to compliance frameworks
        classification["compliance_impact"] = self._map_to_compliance(vulnerability_type)
        
        # Calculate risk score
        classification["risk_score"] = self._calculate_risk_score(classification)
        
        return classification
    
    def _find_relevant_cves(self, vuln_type: str, details: Dict[str, Any]) -> List[Dict[str, str]]:
        """Find relevant CVEs for the vulnerability."""
        cves = []
        
        # Check direct CVE patterns
        if vuln_type in self.cve_db:
            cve_info = self.cve_db[vuln_type]
            for cve_id in cve_info["cves"]:
                cves.append({
                    "id": cve_id,
                    "description": cve_info["description"]
                })
        
        # Check for library-specific CVEs based on file content
        file_path = details.get("file_path", "")
        if "requirements.txt" in file_path or "package.json" in file_path:
            # Could integrate with CVE databases here
            pass
            
        return cves
    
    def _map_to_compliance(self, vuln_type: str) -> List[Dict[str, str]]:
        """Map vulnerability to relevant compliance requirements."""
        compliance_impact = []
        
        # Security testing requirements (most vulnerabilities)
        if vuln_type in self.cwe_db:
            compliance_impact.extend([
                {
                    "framework": "PCI DSS 4.0",
                    "requirement": "6.2.4",
                    "description": "Custom application security testing"
                },
                {
                    "framework": "ISO 27001:2022", 
                    "control": "A.8.25",
                    "description": "Application security testing"
                },
                {
                    "framework": "NIST CSF 2.0",
                    "function": "ID.RA",
                    "description": "Risk Assessment processes"
                }
            ])
        
        # Data protection specific
        if vuln_type in ["sql_injection", "xss", "hardcoded_secrets"]:
            compliance_impact.append({
                "framework": "HIPAA",
                "safeguard": "164.312",
                "description": "Technical safeguards for data protection"
            })
        
        return compliance_impact
    
    def _calculate_risk_score(self, classification: Dict[str, Any]) -> int:
        """Calculate numeric risk score (0-100)."""
        base_scores = {
            "critical": 90,
            "high": 70, 
            "medium": 50,
            "low": 30
        }
        
        score = base_scores.get(classification["severity"], 50)
        
        # Increase score for CVEs
        if classification["cves"]:
            score += len(classification["cves"]) * 5
            
        # Increase score for compliance impact
        if classification["compliance_impact"]:
            score += len(classification["compliance_impact"]) * 2
            
        return min(score, 100)
    
    def generate_compliance_report(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate compliance report for detected vulnerabilities."""
        report = {
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "by_severity": {"critical": 0, "high": 0, "medium": 0, "low": 0},
                "by_framework": {}
            },
            "owasp_top10_coverage": {},
            "compliance_gaps": [],
            "recommendations": []
        }
        
        # Count by severity
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "medium")
            report["summary"]["by_severity"][severity] += 1
        
        # Map to OWASP Top 10
        owasp_categories = {}
        for vuln in vulnerabilities:
            owasp_cat = vuln.get("owasp_category", "Unknown")
            owasp_categories[owasp_cat] = owasp_categories.get(owasp_cat, 0) + 1
        
        report["owasp_top10_coverage"] = owasp_categories
        
        # Generate recommendations
        if report["summary"]["by_severity"]["critical"] > 0:
            report["recommendations"].append(
                "Critical vulnerabilities detected - immediate remediation required"
            )
        
        if report["summary"]["by_severity"]["high"] > 5:
            report["recommendations"].append(
                "High number of high-severity issues - implement security code review"
            )
            
        return report


def enhance_issue_with_mapping(issue: Dict[str, Any]) -> Dict[str, Any]:
    """Enhance an existing issue with vulnerability mapping information."""
    mapper = VulnerabilityMapper()
    
    # Determine vulnerability type from issue content
    vuln_type = _detect_vulnerability_type(issue)
    
    if vuln_type:
        classification = mapper.classify_vulnerability(vuln_type, issue)
        issue.update({
            "vulnerability_classification": classification,
            "cwe_id": classification["cwe"]["id"] if classification["cwe"] else None,
            "owasp_category": classification["owasp_category"],
            "risk_score": classification["risk_score"],
            "compliance_impact": classification["compliance_impact"]
        })
    
    return issue


def _detect_vulnerability_type(issue: Dict[str, Any]) -> Optional[str]:
    """Detect vulnerability type from issue description and code."""
    title = issue.get("title", "").lower()
    description = issue.get("description", "").lower()
    suggestion = issue.get("suggestion", "").lower()
    
    # Pattern matching for vulnerability types
    if any(term in title + description for term in ["sql injection", "sql query", "sql statement"]):
        return "sql_injection"
    elif any(term in title + description for term in ["xss", "cross-site scripting", "script injection"]):
        return "xss"
    elif any(term in title + description for term in ["command injection", "os command", "shell command"]):
        return "command_injection"
    elif any(term in title + description for term in ["path traversal", "directory traversal", "../"]):
        return "path_traversal"
    elif any(term in title + description for term in ["hardcoded", "secret", "password", "api key"]):
        return "hardcoded_secrets"
    elif any(term in title + description for term in ["weak crypto", "weak encryption", "md5", "sha1"]):
        return "weak_crypto"
    elif any(term in title + description for term in ["weak random", "predictable", "random.random"]):
        return "insecure_random"
    elif any(term in title + description for term in ["xml external", "xxe", "xml entity"]):
        return "xml_external_entity"
    elif any(term in title + description for term in ["buffer overflow", "buffer overrun"]):
        return "buffer_overflow"
    elif any(term in title + description for term in ["deserialization", "pickle", "unsafe load"]):
        return "insecure_deserialization"
    elif any(term in title + description for term in ["insufficient log", "missing log", "no logging"]):
        return "insufficient_logging"
    elif any(term in title + description for term in ["ssrf", "server-side request", "request forgery"]):
        return "ssrf"
    
    return None
